#!/usr/bin/env php
<?php # (jEdit options) :folding=explicit:collapseFolds=1:
/*****************************************************************************
    A very simple system for distributing jobs via SSH.
    Each job should act as a Unix filter,
    accepting input on stdin and writing output to stdout.
    
    Before running, fill in values below for $workers.
    
    Local workers are "sh -c".
    Remote workers are (for example) "ssh user@host.com".
    Two-hop workers can be given as "ssh user1@gateway ssh user2@internal".
    SSH passwords should be supplied by RSA or DSA keys,
    with ssh-agent already running if the keys are password protected.
    
INPUTS / SWITCHES (via $_SERVER['argv']):
    inDir           a directory of input files to pass through the filter
    outDir          a directory to put the output files in
    filterCmd       a command to run on all the files, assuming input from
                    stdin and output to stdout. Should be enclosed in quotes
                    to protect it from the shell.

*****************************************************************************/
$workers = array(
    // Local machine is dual core
    "sh -c", // a local worker
    "sh -c", // a local worker
    
    // Rarely in use
    "ssh iwd@quiddity.biochem.duke.edu ssh quirk",      // back room public Q-client
    "ssh iwd@quiddity.biochem.duke.edu ssh quirk",
    "ssh iwd@quiddity.biochem.duke.edu ssh quake",      // Vince's Q-client
    "ssh iwd@quiddity.biochem.duke.edu ssh quake",
    "ssh iwd@quiddity.biochem.duke.edu ssh slide",      // Gary's Q-client
    "ssh iwd@quiddity.biochem.duke.edu ssh slide",

    // Older machines (single core), rarely in use
    "ssh iwd@richardsons.biochem.duke.edu ssh soar",    // back room public R-client
    "ssh iwd@richardsons.biochem.duke.edu ssh song",    // Sandra's R-client / public
    
    // Generally in use
    #"ssh iwd@richardsons.biochem.duke.edu ssh sack",    // Laura's R-client
    #"ssh iwd@richardsons.biochem.duke.edu ssh sack",
    #"ssh iwd@richardsons.biochem.duke.edu ssh slip",    // Gary's R-client
    #"ssh iwd@richardsons.biochem.duke.edu ssh slip",
    #"ssh iwd@richardsons.biochem.duke.edu ssh seed",    // Vince's R-client
    #"ssh iwd@richardsons.biochem.duke.edu ssh seed",
    #"ssh iwd@richardsons.biochem.duke.edu ssh sail",    // Bob's R-client
    #"ssh iwd@richardsons.biochem.duke.edu ssh sail",
    #"ssh iwd@richardsons.biochem.duke.edu ssh soot",    // Jane's R-client
    #"ssh iwd@richardsons.biochem.duke.edu ssh soot",
);

// EVERY *top-level* page must start this way:
// 1. Define it's relationship to the root of the MolProbity installation.
// Pages in subdirectories of lib/ or public_html/ will need more "/.." 's.
    if(!defined('MP_BASE_DIR')) define('MP_BASE_DIR', realpath(dirname(__FILE__).'/..'));
// 2. Include core functionality - defines constants, etc.
    require_once(MP_BASE_DIR.'/lib/core.php');
// 3. Restore session data. If you don't want to access the session
// data for some reason, you must call mpInitEnvirons() instead.
    mpInitEnvirons();       // use std PATH, etc.
    //mpStartSession(true);   // create session dir
// 5. Set up reasonable values to emulate CLI behavior if we're CGI
    set_time_limit(0); // don't want to bail after 30 sec!
// 6. Unlimited memory for processing large files
    ini_set('memory_limit', -1);

#{{{ dispatchJob - launches a job on an available host
############################################################################
/**
* We have this stupid, hack, blocking way of distributing jobs
* because PHP has no thread support, and pcntl_fork() isn't always available.
*/
function dispatchJob($inpath, $outpath)
{
    global $workers, $sleepTime;
    while(true)
    {
        foreach($workers as $idx => $worker)
        {
            if(!isset($worker['lockfile']) || !file_exists($worker['lockfile']))
            {
                $lockfile = mpTempfile("tmp_gridlock_");
                $workers[$idx]['lockfile'] = $lockfile;
                $cmd = "(touch $lockfile; cat $inpath | $worker[ssh] '$worker[cmd]'; rm $lockfile) > $outpath 2>&1 &";
                echo $cmd . "\n";
                exec($cmd);
                return;
            }
        }
        // no host available -- sleep for a while and try again
        #echo "No worker for job -- sleeping...\n";
        sleep($sleepTime);
    }
}
#}}}########################################################################

#{{{ waitForJobs - waits for all jobs to finish
############################################################################
/**
* Documentation for this function.
*/
function waitForJobs()
{
    global $workers, $sleepTime;
    while(true)
    {
        $still_going = 0;
        foreach($workers as $idx => $worker)
        {
            if(isset($worker['lockfile']) && file_exists($worker['lockfile']))
                $still_going++;
        }
        if($still_going == 0) return;
        echo "$still_going jobs still in progress...\n";
        sleep($sleepTime);
    }
}
#}}}########################################################################

#{{{ a_function_definition - sumary_statement_goes_here
############################################################################
/**
* Documentation for this function.
*/
//function someFunctionName() {}
#}}}########################################################################

# MAIN - the beginning of execution for this page
############################################################################
// Default options
$allowClobber   = false;    // run job even if we overwrite file?
$sleepTime      = 2;        // time to sleep if all workers are busy

// First argument is the name of this script...
if(is_array($_SERVER['argv'])) foreach(array_slice($_SERVER['argv'], 1) as $arg)
{
    if(!isset($inDir))          $inDir = $arg;
    elseif(!isset($outDir))     $outDir = $arg;
    elseif(!isset($filterCmd))  $filterCmd = $arg;
    else                        die("Too many or unrecognized arguments: '$arg'\n");
}

if(!isset($inDir))          die("No input directory specified.\n");
elseif(!is_dir($inDir))     die("Input directory '$inDir' does not exist.\n");
elseif(!isset($outDir))     die("No output directory specified.\n");
elseif(!is_dir($outDir))    die("Output directory '$outDir' does not exist.\n");
elseif(realpath($inDir) == realpath($outDir))
    dir("Input and output directories point to the same place.\n");
elseif(!isset($filterCmd))  die("No filter command was provided.\n");

// Convert $workers into a more detailed data structure.
foreach($workers as $idx => $ssh_cmd)
{
    // Workers can also be given as arrays with 'ssh', 'cmd'
    // instead of simple strings, in case 'cmd' varies by host.
    if(!is_array($ssh_cmd))
    {
        $workers[$idx] = array(
            'ssh' => $ssh_cmd,
            'cmd' => $filterCmd,
        );
    }
}

foreach(listDir($inDir) as $inFile) //if(endsWith($inFile, ".pdb"))
{
    $inpath     = "$inDir/$inFile";
    $outpath    = "$outDir/$inFile";
    if(!$allowClobber && file_exists($outpath))
        echo "Skipping $inFile: output file already exists.\n";
    else
        dispatchJob($inpath, $outpath);
}


############################################################################
// Clean up and go home
waitForJobs();
//mpDestroySession(); // only call this if we created one
?>
